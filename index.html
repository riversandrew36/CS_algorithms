<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top CS Algorithms Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: A two-column SPA with a persistent sidebar navigation for algorithm selection and a dynamic main content area. This master-detail layout is highly intuitive for exploring a list of items. Users click an algorithm to instantly view its definition, real-world application, complexity analysis (visualized with a chart), and runnable Python code. This design was chosen to provide a structured, non-linear, and interactive learning experience, superior to a simple linear document for study purposes. -->
    <!-- Visualization & Content Choices: Report Info: List of algorithms -> Goal: Education & Interaction -> Viz/Presentation: Each algorithm gets a detail view with structured text, a styled code block, and a Chart.js bar chart for time/space complexity. -> Interaction: Sidebar clicks update the main view instantly without a page reload; a 'Run Code' button simulates the Python code's execution for a sample input. -> Justification: This approach combines clear textual explanation with a simple visual aid (the chart) and interactive reinforcement (the code simulation) to cater to different learning styles and enhance comprehension. -> Library/Method: Chart.js for canvas-based charts, custom vanilla JS for all state management and interactivity. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        :root {
            --bg-main: #f5f5f4;
            --bg-sidebar: #e7e5e4;
            --bg-card: #ffffff;
            --text-primary: #1c1917;
            --text-secondary: #57534e;
            --accent-primary: #2563eb;
            --accent-hover: #1d4ed8;
            --border-color: #d6d3d1;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-primary);
        }
        .sidebar-item.active {
            background-color: var(--accent-primary);
            color: white;
            font-weight: 600;
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.9em;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 250px;
            max-height: 300px;
        }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="antialiased">

    <div class="flex flex-col h-screen">
       <header class="bg-white shadow-sm p-4 border-b border-stone-200">
    <div class="flex flex-col items-center">
        <button id="home-btn"
            class="px-4 py-2 bg-blue-600 text-white text-2xl font-bold rounded-lg shadow-md hover:bg-blue-700 transition-colors">
            Computer Science Algorithms Explorer
        </button>
        <p class="text-center text-stone-500 mt-2">
            An interactive guide to essential algorithms for your CS studies.
        </p>
    </div>
</header>

        <div class="flex flex-1 overflow-hidden">
            <aside id="sidebar" class="w-1/4 bg-stone-200 p-4 overflow-y-auto border-r border-stone-300">
                <h2 class="text-lg font-semibold mb-3 text-stone-700">Algorithm List</h2>
                <nav id="algorithm-nav" class="space-y-2">
                </nav>
            </aside>

            <main id="main-content" class="flex-1 p-6 lg:p-8 overflow-y-auto">
                <div id="welcome-message" class="text-center h-full flex flex-col justify-center items-center">
                    <div class="max-w-2xl">
                         <div class="text-5xl mb-4">ðŸš€</div>
                        <h2 class="text-3xl font-bold text-stone-700">Welcome!</h2>
                        <p class="text-lg text-stone-500 mt-2">Select an algorithm from the list on the left to get started. You'll find a detailed definition, a real-world example, a complexity analysis, and runnable Python code for each one.</p>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        const algorithmsData = [
            {
                id: 0,
                name: 'Binary Search',
                definition: 'A highly efficient search algorithm that works on sorted arrays. It repeatedly divides the search interval in half. If the value of the search key is less than the item in the middle of the interval, it narrows the interval to the lower half. Otherwise, it narrows it to the upper half. This process continues until the value is found or the interval is empty.',
                example: 'Looking up a word in a physical dictionary. You open to the middle, see if your word comes before or after, and then repeat the process on that smaller section. This is much faster than starting from the first page and checking every word.',
                timeComplexity: 'O(log n)',
                spaceComplexity: 'O(1) for iterative, O(log n) for recursive',
                code: `def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

# Example usage:
sorted_array = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
target_value = 23
result = binary_search(sorted_array, target_value)
print(f"Searching for {target_value} in {sorted_array}")
if result != -1:
    print(f"Element found at index: {result}")
else:
    print("Element not found")`,
                output: `Searching for 23 in [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Element found at index: 5`
            },
            {
                id: 1,
                name: 'KMP Algorithm',
                definition: 'The Knuth-Morris-Pratt (KMP) algorithm is a string-searching algorithm that searches for occurrences of a "word" W within a main "text" T by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.',
                example: 'A text editor\'s "Find" functionality (Ctrl+F). When you search for "pattern" in a large document, KMP can find all occurrences efficiently without re-scanning parts of the text it has already checked, making it very fast.',
                timeComplexity: 'O(n + m)',
                spaceComplexity: 'O(m)',
                code: `def compute_lps(pattern):
    lps = [0] * len(pattern)
    length, i = 0, 1
    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    n, m = len(text), len(pattern)
    lps = compute_lps(pattern)
    i, j = 0, 0
    results = []
    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == m:
            results.append(i - j)
            j = lps[j - 1]
        elif i < n and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    return results

# Example usage:
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(f"Searching for '{pattern}' in '{text}'")
found_indices = kmp_search(text, pattern)
print(f"Pattern found at indices: {found_indices}")`,
                output: `Searching for 'ABABCABAB' in 'ABABDABACDABABCABAB'
Pattern found at indices: [10]`
            },
            {
                id: 2,
                name: 'Quick Sort',
                definition: 'A highly efficient, comparison-based, divide-and-conquer sorting algorithm. It works by selecting a \'pivot\' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.',
                example: 'Organizing a list of student test scores from highest to lowest. You could pick a pivot score (e.g., 85), put all scores higher than 85 on one side and all lower scores on the other, and then repeat this process for each subgroup until the entire list is sorted.',
                timeComplexity: 'O(n log n) average, O(n^2) worst',
                spaceComplexity: 'O(log n)',
                code: `def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
unsorted_array = [10, 7, 8, 9, 1, 5]
print(f"Unsorted array: {unsorted_array}")
sorted_array = quick_sort(unsorted_array)
print(f"Sorted array: {sorted_array}")`,
                output: `Unsorted array: [10, 7, 8, 9, 1, 5]
Sorted array: [1, 5, 7, 8, 9, 10]`
            },
            {
                id: 3,
                name: 'Merge Sort',
                definition: 'A stable, comparison-based, divide-and-conquer sorting algorithm. It works by dividing the unsorted list into n sub-lists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges sub-lists to produce new sorted sub-lists until there is only one sub-list remaining, which will be the sorted list.',
                example: 'A large e-commerce site needs to sort products by price. The entire product list can be broken into smaller chunks, sorted individually (even on different computers), and then efficiently merged back together to create the final, fully sorted list for display.',
                timeComplexity: 'O(n log n)',
                spaceComplexity: 'O(n)',
                code: `def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
    return arr

# Example usage:
unsorted_array = [38, 27, 43, 3, 9, 82, 10]
print(f"Unsorted array: {unsorted_array}")
sorted_array = merge_sort(unsorted_array)
print(f"Sorted array: {sorted_array}")`,
                output: `Unsorted array: [38, 27, 43, 3, 9, 82, 10]
Sorted array: [3, 9, 10, 27, 38, 43, 82]`
            },
            {
                id: 4,
                name: 'Fast Fourier Transform (FFT)',
                definition: 'An algorithm that computes the Discrete Fourier Transform (DFT) of a sequence, or its inverse. FFTs are used for converting a signal from its original domain (often time or space) to a representation in the frequency domain. This is incredibly useful for signal processing and data analysis.',
                example: 'MP3 compression and digital audio processing. An audio signal (like a song) is a complex wave. FFT breaks this wave down into its constituent frequencies (bass, midrange, treble). The compression algorithm can then remove frequencies that are inaudible to the human ear, dramatically reducing file size without a noticeable loss in quality.',
                timeComplexity: 'O(n log n)',
                spaceComplexity: 'O(n)',
                code: `import numpy as np

# Example usage (requires numpy library):
# Create a sample signal: a 10 Hz sine wave + a 25 Hz sine wave
sampling_rate = 100  # Hz
duration = 2  # seconds
t = np.linspace(0, duration, sampling_rate * duration, endpoint=False)
signal = np.sin(10 * 2 * np.pi * t) + 0.5 * np.sin(25 * 2 * np.pi * t)

# Compute the FFT
fft_result = np.fft.fft(signal)
frequencies = np.fft.fftfreq(len(fft_result), 1/sampling_rate)

# Find the dominant frequencies
positive_freq_indices = np.where(frequencies > 0)
dominant_freqs = frequencies[positive_freq_indices][np.argsort(-np.abs(fft_result[positive_freq_indices]))]

print("Original signal is a mix of sine waves.")
print(f"Detected dominant frequencies (Hz): {dominant_freqs[:2].round(2)}")`,
                output: `Original signal is a mix of sine waves.
Detected dominant frequencies (Hz): [10. 25.]`
            },
            {
                id: 5,
                name: 'Depth-First Search (DFS)',
                definition: 'An algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking. It uses a stack (often implicitly via recursion) to keep track of nodes to visit.',
                example: 'Solving a maze. You follow one path as deep as you can. If you hit a dead end, you backtrack to the last junction and try a different path. You repeat this until you find the exit. DFS explores one full option before trying another.',
                timeComplexity: 'O(V + E)',
                spaceComplexity: 'O(V)',
                code: `def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start, end=' ')
    for neighbor in graph[start] - visited:
        dfs(graph, neighbor, visited)
    return visited

# Example usage (Adjacency List):
graph = {
    'A': {'B', 'C'},
    'B': {'A', 'D', 'E'},
    'C': {'A', 'F'},
    'D': {'B'},
    'E': {'B', 'F'},
    'F': {'C', 'E'}
}
print("DFS traversal starting from node 'A':")
dfs(graph, 'A')`,
                output: `DFS traversal starting from node 'A':
A C F E B D `
            },
            {
                id: 6,
                name: 'Breadth-First Search (BFS)',
                definition: 'An algorithm for traversing or searching tree or graph data structures. It starts at the tree root and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. It uses a queue to keep track of nodes to visit.',
                example: 'Finding the shortest path in an unweighted graph, like finding the minimum number of connections between two people on a social network. BFS explores level by level, so the first time it finds the target person, it guarantees it found them through the shortest path of connections.',
                timeComplexity: 'O(V + E)',
                spaceComplexity: 'O(V)',
                code: `from collections import deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Example usage (Adjacency List):
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
print("BFS traversal starting from node 'A':")
bfs(graph, 'A')`,
                output: `BFS traversal starting from node 'A':
A B C D E F `
            },
            {
                id: 7,
                name: 'Topological Sort',
                definition: 'A linear ordering of the vertices of a directed acyclic graph (DAG) such that for every directed edge from vertex u to vertex v, u comes before v in the ordering. It is not possible if the graph has a cycle.',
                example: 'Determining the order to take university courses with prerequisites. Course A must be taken before B, and B before C. A topological sort will produce a valid sequence of courses to take, like [A, B, C]. It is also used in task scheduling in project management.',
                timeComplexity: 'O(V + E)',
                spaceComplexity: 'O(V)',
                code: `from collections import deque

def topological_sort(graph):
    in_degree = {u: 0 for u in graph}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    
    queue = deque([u for u in graph if in_degree[u] == 0])
    topo_order = []
    
    while queue:
        u = queue.popleft()
        topo_order.append(u)
        for v in graph[u]:
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)
    
    if len(topo_order) == len(graph):
        return topo_order
    else:
        return "Graph has a cycle!"

# Example usage (prerequisites):
graph = {
    'CS101': ['CS102', 'CS103'],
    'CS102': ['CS201'],
    'CS103': ['CS201'],
    'CS201': []
}
print("Valid course order:")
print(topological_sort(graph))`,
                output: `Valid course order:
['CS101', 'CS102', 'CS103', 'CS201']`
            },
            {
                id: 8,
                name: 'Lowest Common Ancestor (LCA)',
                definition: 'The lowest common ancestor is defined between two nodes p and q as the lowest node in a tree that has both p and q as descendants (where we allow a node to be a descendant of itself).',
                example: 'In a file system directory structure (which is a tree), finding the LCA of two files helps determine the smallest shared folder containing both. This can be useful for setting permissions or finding related files.',
                timeComplexity: 'Varies, O(log N) with preprocessing',
                spaceComplexity: 'Varies, O(N) with preprocessing',
                code: `class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowest_common_ancestor(root, p, q):
    if not root or root == p or root == q:
        return root
    
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    
    if left and right:
        return root
    return left or right

# Example usage:
#       3
#      / \\
#     5   1
#    / \\ / \\
#   6  2 0  8
#     / \\
#    7   4
root = TreeNode(3)
root.left = TreeNode(5)
root.right = TreeNode(1)
root.left.left = TreeNode(6)
p = root.left.right = TreeNode(2)
root.right.left = TreeNode(0)
root.right.right = TreeNode(8)
p.left = TreeNode(7)
q = p.right = TreeNode(4)

lca = lowest_common_ancestor(root, p, q)
print(f"LCA of nodes {p.val} and {q.val} is node {lca.val}")`,
                output: `LCA of nodes 2 and 4 is node 2`
            },
            {
                id: 9,
                name: 'A* Search',
                definition: 'A popular pathfinding algorithm used in graphs to find the shortest path from a start node to a target node. It is an informed search algorithm, as it uses a heuristic function to guide its search towards the goal more efficiently than an uninformed search like BFS.',
                example: 'GPS navigation systems in cars and maps apps. A* calculates the shortest/fastest route from your current location to your destination. It considers the actual distance traveled (cost) and an estimated distance to the goal (heuristic), avoiding routes that head in the wrong direction.',
                timeComplexity: 'O(E)',
                spaceComplexity: 'O(V)',
                code: `import heapq

def a_star_search(graph, start, goal, heuristic):
    open_set = [(0, start)]
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic[start]

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]

        for neighbor, weight in graph[current].items():
            tentative_g_score = g_score[current] + weight
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic[neighbor]
                if (f_score[neighbor], neighbor) not in open_set:
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return "Path not found"
    
# Example: simplified road map graph
graph = {
    'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'D': 2, 'E': 5},
    'C': {'A': 4, 'F': 3}, 'D': {'B': 2},
    'E': {'B': 5, 'G': 2}, 'F': {'C': 3}, 'G': {'E': 2}
}
# Heuristic: straight-line distance to goal 'G'
heuristic = {'A': 7, 'B': 6, 'C': 4, 'D': 5, 'E': 2, 'F': 3, 'G': 0}

path = a_star_search(graph, 'A', 'G', heuristic)
print(f"Shortest path from A to G: {' -> '.join(path)}")`,
                output: `Shortest path from A to G: A -> B -> E -> G`
            },
            {
                id: 10,
                name: "Dijkstra's Algorithm",
                definition: 'An algorithm for finding the shortest paths between nodes in a weighted graph, which may represent, for example, road networks. It picks an unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor\'s distance if smaller.',
                example: 'IP routing in computer networks. When data packets are sent across the internet, routers use Dijkstra\'s algorithm to find the shortest (lowest latency or cost) path to send the packet to its destination through the network of connected routers.',
                timeComplexity: 'O(E log V)',
                spaceComplexity: 'O(V)',
                code: `import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    return distances

# Example graph:
graph = {
    'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1}, 'D': {'B': 5, 'C': 1}
}
shortest_paths = dijkstra(graph, 'A')
print(f"Shortest paths from A: {shortest_paths}")`,
                output: `Shortest paths from A: {'A': 0, 'B': 1, 'C': 3, 'D': 4}`
            },
            {
                id: 11,
                name: 'Minimum Spanning Tree',
                definition: 'A subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. Common algorithms to find it are Prim\'s and Kruskal\'s.',
                example: 'Designing a telecommunications network to connect multiple cities. The cities are vertices and the cost to lay cable between them is the edge weight. A Minimum Spanning Tree finds the cheapest way to lay cable to connect all cities.',
                timeComplexity: 'O(E log V) or O(E log E)',
                spaceComplexity: 'O(V + E)',
                code: `# Kruskal's Algorithm implementation
def find_parent(parent, i):
    if parent[i] == i:
        return i
    return find_parent(parent, parent[i])

def union(parent, rank, x, y):
    x_root = find_parent(parent, x)
    y_root = find_parent(parent, y)
    if rank[x_root] < rank[y_root]:
        parent[x_root] = y_root
    elif rank[x_root] > rank[y_root]:
        parent[y_root] = x_root
    else:
        parent[y_root] = x_root
        rank[x_root] += 1

def kruskal_mst(graph):
    result = []
    i, e = 0, 0
    graph = sorted(graph, key=lambda item: item[2])
    num_vertices = len(set([u for u, v, w in graph] + [v for u, v, w in graph]))
    parent = [node for node in range(num_vertices)]
    rank = [0] * num_vertices

    while e < num_vertices - 1 and i < len(graph):
        u, v, w = graph[i]
        i += 1
        x = find_parent(parent, u)
        y = find_parent(parent, v)
        if x != y:
            e += 1
            result.append((u, v, w))
            union(parent, rank, x, y)
    
    total_weight = sum(w for u, v, w in result)
    return result, total_weight

# Graph represented as a list of edges (u, v, weight)
graph_edges = [(0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4)]
mst, weight = kruskal_mst(graph_edges)
print(f"Edges in MST: {mst}")
print(f"Total weight: {weight}")`,
                output: `Edges in MST: [(2, 3, 4), (0, 3, 5), (0, 1, 10)]
Total weight: 19`
            },
            {
                id: 12,
                name: 'Binary Exponentiation',
                definition: 'Also known as exponentiation by squaring, it is a fast method for computing large integer powers of a number. It is based on the observation that for a positive integer n, x^n can be calculated more efficiently by repeatedly squaring x and combining the results according to the binary representation of n.',
                example: 'In cryptography, algorithms like RSA require calculating very large powers of numbers modulo another number (e.g., 5^12345 mod 789). Standard multiplication would be incredibly slow. Binary exponentiation makes these calculations feasible in a short amount of time.',
                timeComplexity: 'O(log n)',
                spaceComplexity: 'O(1)',
                code: `def binary_power(base, exp):
    res = 1
    base %= 1000000007  # Example modulo for large numbers
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % 1000000007
        base = (base * base) % 1000000007
        exp //= 2
    return res

# Example usage:
base = 3
exponent = 10
result = binary_power(base, exponent)
print(f"{base}^{exponent} = {result} (actual: {3**10})")`,
                output: `3^10 = 59049 (actual: 59049)`
            },
            {
                id: 13,
                name: 'Knapsack Problem',
                definition: 'A problem in combinatorial optimization. Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. The 0/1 knapsack variant restricts the number of each item to zero or one.',
                example: 'A delivery truck has a maximum weight capacity. You have a list of packages, each with a weight and a delivery fee (value). The knapsack algorithm helps you decide which packages to load onto the truck to maximize your total delivery fees without exceeding the weight limit.',
                timeComplexity: 'O(nW)',
                spaceComplexity: 'O(nW)',
                code: `def knapsack_01(values, weights, capacity):
    n = len(values)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                # Max of including the item or not including it
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
    return dp[n][capacity]

# Example usage:
values = [60, 100, 120]
weights = [10, 20, 30]
capacity = 50
max_val = knapsack_01(values, weights, capacity)
print(f"Maximum value in knapsack: {max_val}")`,
                output: `Maximum value in knapsack: 220`
            },
            {
                id: 14,
                name: 'Longest Common Subsequence (LCS)',
                definition: 'A problem that aims to find the longest subsequence common to all sequences in a set of sequences (often just two). A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.',
                example: 'In bioinformatics, LCS is used to compare DNA sequences. The longer the common subsequence between two DNA strands, the more similar and evolutionarily related they are. It\'s also used by version control systems like Git to determine the differences between two versions of a file.',
                timeComplexity: 'O(mn)',
                spaceComplexity: 'O(mn)',
                code: `def lcs(X, Y):
    m, n = len(X), len(Y)
    L = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])
    
    return L[m][n]

# Example usage:
X = "AGGTAB"
Y = "GXTXAYB"
length = lcs(X, Y)
print(f"Length of LCS between '{X}' and '{Y}' is {length}") # LCS is "GTAB"`,
                output: `Length of LCS between 'AGGTAB' and 'GXTXAYB' is 4`
            },
            {
                id: 15,
                name: 'Greatest Common Divisor (GCD)',
                definition: 'The greatest common divisor of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. The most common method for computing it is the Euclidean algorithm.',
                example: 'Simplifying a fraction. To simplify 24/36, you find the GCD of 24 and 36, which is 12. You then divide both the numerator and the denominator by 12 to get the simplified fraction 2/3.',
                timeComplexity: 'O(log(min(a,b)))',
                spaceComplexity: 'O(1)',
                code: `# Euclidean algorithm
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Example usage:
num1 = 54
num2 = 24
result = gcd(num1, num2)
print(f"The GCD of {num1} and {num2} is {result}")`,
                output: `The GCD of 54 and 24 is 6`
            },
        ];

        const sidebarNav = document.getElementById('algorithm-nav');
        const mainContent = document.getElementById('main-content');
        const welcomeMessage = document.getElementById('welcome-message');
        let complexityChart = null;

        function displayAlgorithm(algo) {
            welcomeMessage.style.display = 'none';

            mainContent.innerHTML = `
                <div id="welcome-message" class="text-center h-full flex flex-col justify-center items-center" style="display: none;">
                    <div class="max-w-2xl">
                         <div class="text-5xl mb-4">ðŸš€</div>
                        <h2 class="text-3xl font-bold text-stone-700">Welcome!</h2>
                        <p class="text-lg text-stone-500 mt-2">Select an algorithm from the list on the left to get started. You'll find a detailed definition, a real-world example, a complexity analysis, and runnable Python code for each one.</p>
                    </div>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-3xl font-bold mb-2 text-stone-800">${algo.name}</h2>
                    
                    <div class="mt-6">
                        <h3 class="text-xl font-semibold border-b pb-2 mb-3 text-stone-700">Definition</h3>
                        <p class="text-stone-600 leading-relaxed">${algo.definition}</p>
                    </div>

                    <div class="mt-6">
                        <h3 class="text-xl font-semibold border-b pb-2 mb-3 text-stone-700">Real-World Example</h3>
                        <p class="text-stone-600 leading-relaxed">${algo.example}</p>
                    </div>

                    <div class="mt-6">
                        <h3 class="text-xl font-semibold border-b pb-2 mb-3 text-stone-700">Complexity Analysis</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                            <div>
                                <p class="text-stone-600"><span class="font-semibold">Time Complexity:</span> ${algo.timeComplexity}</p>
                                <p class="text-stone-600"><span class="font-semibold">Space Complexity:</span> ${algo.spaceComplexity}</p>
                            </div>
                            <div class="chart-container">
                                <canvas id="complexityChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div class="mt-6">
                        <h3 class="text-xl font-semibold border-b pb-2 mb-3 text-stone-700">Python Implementation</h3>
                        <div class="code-block">
                            <pre><code>${algo.code}</code></pre>
                        </div>
                        <button id="run-code-btn" class="mt-4 bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors">Run Code</button>
                        <div id="code-output-wrapper" class="hidden mt-4">
                            <h4 class="font-semibold text-stone-600">Output:</h4>
                            <div class="code-block !bg-gray-700 !text-gray-200 mt-2">
                                <pre><code id="code-output"></code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            const ctx = document.getElementById('complexityChart').getContext('2d');
            if (complexityChart) {
                complexityChart.destroy();
            }
            complexityChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Time', 'Space'],
                    datasets: [{
                        label: 'Complexity',
                        data: [1, 1],
                        backgroundColor: ['rgba(59, 130, 246, 0.5)', 'rgba(239, 68, 68, 0.5)'],
                        borderColor: ['rgba(59, 130, 246, 1)', 'rgba(239, 68, 68, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    if (context.dataIndex === 0) return algo.timeComplexity;
                                    return algo.spaceComplexity;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: { 
                            grid: { display: false },
                             ticks: { font: { weight: 'bold' } }
                        }
                    }
                }
            });

            document.getElementById('run-code-btn').addEventListener('click', () => {
                const outputWrapper = document.getElementById('code-output-wrapper');
                const outputEl = document.getElementById('code-output');
                outputEl.textContent = algo.output;
                outputWrapper.classList.remove('hidden');
            });
        }

        document.getElementById('home-btn').addEventListener('click', () => {
            // Reset the main content to show only the welcome message
            mainContent.innerHTML = `
                <div id="welcome-message" class="text-center h-full flex flex-col justify-center items-center">
                    <div class="max-w-2xl">
                         <div class="text-5xl mb-4">ðŸš€</div>
                        <h2 class="text-3xl font-bold text-stone-700">Welcome!</h2>
                        <p class="text-lg text-stone-500 mt-2">Select an algorithm from the list on the left to get started. You'll find a detailed definition, a real-world example, a complexity analysis, and runnable Python code for each one.</p>
                    </div>
                </div>
            `;

            // Destroy the chart if it exists
            if (complexityChart) {
                complexityChart.destroy();
                complexityChart = null;
            }

            // Reset active sidebar item
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.remove('active');
            });
        });

        function setActiveLink(id) {
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`.sidebar-item[data-id="${id}"]`).classList.add('active');
        }

        algorithmsData.forEach((algo) => {
            const button = document.createElement('button');
            button.textContent = algo.name;
            button.className = 'sidebar-item w-full text-left p-2 rounded-md hover:bg-stone-300 transition-colors';
            button.dataset.id = algo.id;
            button.addEventListener('click', () => {
                displayAlgorithm(algo);
                setActiveLink(algo.id);
            });
            sidebarNav.appendChild(button);
        });

    </script>
</body>
</html>